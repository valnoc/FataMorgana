{# === IMPORTS === #}
{% macro generateImports %}
import Foundation
import Mirage
@testable import {{ argument.testableModule }}
{{ argument.imports }}
{% endmacro %}

{# === ANY === #}
{% macro callAny type %}{#
    #}{% if type|contains:":" %}{#
        #}{% call callAnyDict type %}{#
    #}{% else %}{#
        #}{% if type|contains:"[" %}{#
            #}{% call callAnyArray type %}{#
        #}{% else %}{#
            #}{% call callAnyType type %}{#
        #}{% endif %}{#
    #}{% endif %}{#
#}{% endmacro %}

{% macro callAnyDict type %}{#
    #}any{{ type|replace:"?",""|replace:"<",""|replace:">",""|replace:".",""|replace:"[",""|replace:"]",""|replace:":","" }}Dict(){#
#}{% endmacro %}

{% macro callAnyArray type %}{#
    #}any{{ type|replace:"?",""|replace:"<",""|replace:">",""|replace:".",""|replace:"[",""|replace:"]","" }}Array(){#
#}{% endmacro %}

{% macro callAnyType type %}{#
    #}any{{ type|replace:"?",""|replace:"<",""|replace:">",""|replace:".","" }}(){#
#}{% endmacro %}

{# === FUNC === #}
{## FUNC DECLARATION ##}
{% macro getFuncSel func %}{#
    {% if func|annotated:"mirageSel" %}{{ func.annotations.mirageSel }}{#
    #}{% else %}{{ func.callName }}{% endif %}{#
#}{% endmacro %}

{% macro printFuncDeclaration func %}{#
    #}{% call printFuncOverride func %}func {% call printFuncName func %}{% call printFuncThrows func %}{% call printFuncReturnType func %}{#
#}{% endmacro %}

{% macro printFuncOverride func %}{% if func.definedInType.kind == "class" %}override {% endif %}{% endmacro %}
{% macro printFuncName func %}{{ func.name|replace:" ","" }}{% endmacro %}
{% macro printFuncReturnType func %}{% if not func.returnTypeName.isVoid %} -> {{ func.returnTypeName }}{% endif %}{% endmacro %}
{% macro printFuncThrows func %}{% if func.throws %} throws {% endif %}{% endmacro %}

{## FUNC ARGS ##}
{% macro printMethodArgs method %}{#
    #}{% if method.parameters.count > 0 %}{#
        #}{% for param in method.parameters %}{#
            #} {{ param.name }}{#
            #}{% if not forloop.last %},{% endif %}{#
        #}{% endfor %}{#
    #}{% else %}{#
        #} nil{#
    #}{% endif %}{#
#}{% endmacro %}

{# handler #}
{% macro printMockManagerHandle method methodSel %}{#
    #}mockManager.handle({{ methodSel }}, withDefaultReturnValue: {#
    #}{% if method.returnTypeName.isVoid %}nil{#
    #}{% else %}{% call callAny method.returnTypeName %}{#
    #}{% endif %}{#   
    #}, withArgs:{% call printMethodArgs method %}){#
#}{% endmacro %}

{# mock #}
{% macro generateMockMethod method %}
    {% set methodSel %}{% call getMethodSel method %}{% endset %}
    {##}
    let {{ methodSel }} = "{{ methodSel }}"
    {% call printMethodDeclaration method %} {
        {% if method.returnTypeName.isVoid %}
        {% call printMockManagerHandle method methodSel %}
        {% else %}
        return {% call printMockManagerHandle method methodSel %} as{%if method.returnTypeName.isOptional%}?{%else%}!{%endif%} {{ method.returnTypeName|replace:"?","" }}
        {% endif %}
    }
{% endmacro %}

{# === VAR === #}
{% macro getVarSelGet var %}{% if var|annotated:"mirageSel" %}sel_get_{{ var.annotations.mirageSel }}{% else %}sel_get_{{ var.name }}{% endif %}{% endmacro %}
{% macro getVarSelSet var %}{% if var|annotated:"mirageSel" %}sel_set_{{ var.annotations.mirageSel }}{% else %}sel_set_{{ var.name }}{% endif %}{% endmacro %}

{# handler #}
{% macro printMockVarManagerHandle var varSel %}{#
    #}mockManager.handle({{ varSel }}{#
    #}, withDefaultReturnValue: {#
    #}{% if method.returnTypeName.isVoid %}nil{#
    #}{% else %}{% call callAny method.returnTypeName %}{#
    #}{% endif %}{#   
    #}, withArgs:nil){#
#}{% endmacro %}

{# mock #}
{% macro printOverride method %}{% if method.definedInType.kind == "class" %}override {% endif %}{% endmacro %}

{% macro generateMockVar var %}
    {% set varSelGet %}{% call getVarSelGet var %}{% endset %}
    {% set varSelSet %}{% call getVarSelSet var %}{% endset %}
    {##}
    let {{ varSelGet }} = "{{ varSelGet }}"
    let {{ varSelSet }} = "{{ varSelSet }}"
    {% call printOverride var %}var {{ var.name}}: {{ var.typeName }} {
        get { return mockManager.handle({{ varSelGet }}, withDefaultReturnValue: {% call callAny var.typeName %}, withArgs:nil) as{%if var.isOptional%}?{%else%}!{%endif%} {{ var.typeName|replace:"?","" }}  }
    {% if var.writeAccess != "" and var.writeAccess != "fileprivate" %}
        set(value) { mockManager.handle({{ varSelSet }}, withDefaultReturnValue: nil, withArgs:value) }
    {% endif %}
    }
{% endmacro %}

{# === TYPE === #}
{% macro printCallRealMethodArgs method %}{#
    #}{% for param in method.parameters %}{#
        #}{{ param.argumentLabel }}{#
        #}{% if param.argumentLabel.length > 0 %}:{% endif %}{#
        #} args![{{forloop.counter0}}]{#
        #} as{% if param.isOptional %}?{% else %}!{% endif %}{#
        #} {{ param.typeName.unwrappedTypeName }}{#
        #}{% if not forloop.last %}, {% endif %}{#
    #}{% endfor %}{#
#}{% endmacro %}

{% macro printCallRealMethod method %}{#
    #}{{ method.callName }}({% call printCallRealMethodArgs method %}){#
#}{% endmacro %}

{% macro generateMockProtocol type %}
class Mock{{ type.name }}: {{ type.name }}, Mock {
    
    lazy var mockManager: MockManager = MockManager(self, callRealFuncClosure: { [weak self] (funcName, args) -> Any? in
        guard let __self = self else { return nil }
        return nil
    })
    
    //MARK: - Mock{{ type.name }}
    {% for var in type.allVariables|!definedInExtension|!annotated:"mirageSkip" %}
            {% call generateMockVar var %}

    {% endfor %}

    {% for method in type.allMethods|!definedInExtension|!annotated:"mirageSkip" %}
        {% if not method.isInitializer and not method.isDeinitializer and not method.accessLevel == "fileprivate" %}
            {% call generateMockMethod method %}

        {% endif %}
    {% endfor %}    
}
{% endmacro %}

{% macro generateMockClass type %}
class Mock{{ type.name }}: {{ type.name }}, Mock {
    
    lazy var mockManager: MockManager = MockManager(self, callRealFuncClosure: { [weak self] (funcName, args) -> Any? in
        guard let __self = self else { return nil }
        return __self.callRealFunc(funcName, args)
    })
    fileprivate func callRealFunc(_ funcName:String, _ args:[Any?]?) -> Any? {
        switch funcName {
        {% for method in type.methods|!definedInExtension|!annotated:"mirageSkip" %}
            {% if not method.isInitializer and not method.isDeinitializer and not method.accessLevel == "fileprivate" %}
                {% set methodSel %}{% call getMethodSel method %}{% endset %}
        case {{ methodSel }}:
            return {% if method.throws %}try? {% endif %}super.{% call printCallRealMethod method %}
            {% endif %}
        {% endfor %}
        default:
            return nil
        }
    }
    
    //MARK: - Mock{{ type.name }}
    {% for var in type.allVariables|!definedInExtension|!annotated:"mirageSkip" %}
        {% call generateMockVar var %}
    {% endfor %}

    {% for method in type.methods|!definedInExtension|!annotated:"mirageSkip" %}
        {% if not method.isInitializer and not method.isDeinitializer and not method.accessLevel == "fileprivate" %}
            {% call generateMockMethod method %}
        {% endif %}
    {% endfor %}    
}
{% endmacro %}

{% macro generateMockType type %}
{% if type.kind == "class" %}
    {% call generateMockClass type %}
{% else %}
    {% call generateMockProtocol type %}
{% endif %}
{% endmacro %}

{# === GENERATE MOCKS === #}
{% for type in types.classes|annotated:"mirageMock" %}
// sourcery:file:Mock{{ type.name }}
{% call generateImports %}

{% call generateMockType type %}
// sourcery:end
{% endfor %}

{% for type in types.protocols|annotated:"mirageMock" %}
// sourcery:file:Mock{{ type.name }}
{% call generateImports %}

{% call generateMockType type %}
// sourcery:end
{% endfor %}

{% for type in types.classes|annotated:"miragePartial" %}

// sourcery:file:Mock{{ type.name }}
{% call generateImports %}

class PartialMock{{ type.name }}: Mock{{ type.name }}, PartialMock { }

{% call generateMockType type %}
// sourcery:end

{% endfor %}
</stencil>